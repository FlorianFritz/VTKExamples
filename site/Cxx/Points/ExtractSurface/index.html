<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>ExtractSurface - VTKExamples</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "ExtractSurface";
    var mkdocs_page_input_path = "Cxx/Points/ExtractSurface.md";
    var mkdocs_page_url = "/Cxx/Points/ExtractSurface/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js"></script>
  <script src="../../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> VTKExamples</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Introduction</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../">Cxx</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">ExtractSurface</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#description">Description</a></li>
    

    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">VTKExamples</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
    
    <li>ExtractSurface</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a href="../../../index/">VTKExamples</a>/<a href="../../../Cxx">Cxx</a>/Points/ExtractSurface</p>
<p><img align="right" src="https://github.com/lorensen/VTKExamples/blob/gh-pages/Testing/Baseline/Points/TestExtractSurface.png?raw=true" width="256" /></p>
<h3 id="description">Description</h3>
<p>This example loosely follows the most excellent paper by Curless and Levoy: <a href="https://graphics.stanford.edu/papers/volrange">"A Volumetric Method for Building Complex Models from Range Images."</a> First it estimates normals from the points, then creates a signed distance field, followed by surface extraction of the zero-level set of the distance field.</p>
<p>The image was created using the <a href="https://github.com/lorensen/VTKWikiExamples/blob/master/Testing/Data/Armadillo.ply?raw=true">Armadillo dataset</a></p>
<p><strong>NOTE:</strong> The classes used in this example require vtk 7.1 or later.</p>
<p><strong>ExtractSurface.cxx</strong></p>
<pre><code class="c++">#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkPLYReader.h&gt;
#include &lt;vtkXMLPolyDataReader.h&gt;
#include &lt;vtkOBJReader.h&gt;
#include &lt;vtkSTLReader.h&gt;
#include &lt;vtkPointSource.h&gt;

#include &lt;vtkPCANormalEstimation.h&gt;
#include &lt;vtkSignedDistance.h&gt;
#include &lt;vtkExtractSurface.h&gt;
#include &lt;vtkPointData.h&gt;

#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkRenderWindow.h&gt;
#include &lt;vtkRenderWindowInteractor.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkCamera.h&gt;

#include &lt;vtksys/SystemTools.hxx&gt;

static vtkSmartPointer&lt;vtkPolyData&gt; ReadPolyData(const char *fileName);

int main (int argc, char *argv[])
{
  vtkSmartPointer&lt;vtkPolyData&gt; polyData = ReadPolyData(argc &gt; 1 ? argv[1] : &quot;&quot;);;

  double bounds[6];
  polyData-&gt;GetBounds(bounds);
  double range[3];
  for (int i = 0; i &lt; 3; ++i)
  {
    range[i] = bounds[2*i + 1] - bounds[2*i];
  }

  int sampleSize = polyData-&gt;GetNumberOfPoints() * .00005;
  if (sampleSize &lt; 10)
  {
    sampleSize = 10;
  }
  std::cout &lt;&lt; &quot;Sample size is: &quot; &lt;&lt; sampleSize &lt;&lt; std::endl;
  // Do we need to estimate normals?
  vtkSmartPointer&lt;vtkSignedDistance&gt; distance =
    vtkSmartPointer&lt;vtkSignedDistance&gt;::New();
  if (polyData-&gt;GetPointData()-&gt;GetNormals())
  {
    std::cout &lt;&lt; &quot;Using normals from input file&quot; &lt;&lt; std::endl;
    distance-&gt;SetInputData (polyData);
  }
  else
  {
    std::cout &lt;&lt; &quot;Estimating normals using PCANormalEstimation&quot; &lt;&lt; std::endl;
    vtkSmartPointer&lt;vtkPCANormalEstimation&gt; normals =
      vtkSmartPointer&lt;vtkPCANormalEstimation&gt;::New();
    normals-&gt;SetInputData (polyData);
    normals-&gt;SetSampleSize(sampleSize);
    normals-&gt;SetNormalOrientationToGraphTraversal();
    normals-&gt;FlipNormalsOn();
    distance-&gt;SetInputConnection (normals-&gt;GetOutputPort());
  }
  std::cout &lt;&lt; &quot;Range: &quot;
            &lt;&lt; range[0] &lt;&lt; &quot;, &quot;
            &lt;&lt; range[1] &lt;&lt; &quot;, &quot;
            &lt;&lt; range[2] &lt;&lt; std::endl;
  int dimension = 256;
  double radius = range[0] * .02;
  radius = range[0] / static_cast&lt;double&gt;(dimension) * 3; // ~3 voxels
  std::cout &lt;&lt; &quot;Radius: &quot; &lt;&lt; radius &lt;&lt; std::endl;

  distance-&gt;SetRadius(radius);
  distance-&gt;SetDimensions(dimension, dimension, dimension);
  distance-&gt;SetBounds(
    bounds[0] - range[0] * .1,
    bounds[1] + range[0] * .1,
    bounds[2] - range[1] * .1,
    bounds[3] + range[1] * .1,
    bounds[4] - range[2] * .1,
    bounds[5] + range[2] * .1);

  vtkSmartPointer&lt;vtkExtractSurface&gt; surface =
    vtkSmartPointer&lt;vtkExtractSurface&gt;::New();
  surface-&gt;SetInputConnection (distance-&gt;GetOutputPort());
  surface-&gt;SetRadius(radius * .99);
  surface-&gt;Update();

  vtkSmartPointer&lt;vtkPolyDataMapper&gt; surfaceMapper =
    vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
  surfaceMapper-&gt;SetInputConnection(surface-&gt;GetOutputPort());

  vtkSmartPointer&lt;vtkActor&gt; surfaceActor =
    vtkSmartPointer&lt;vtkActor&gt;::New();
  surfaceActor-&gt;SetMapper(surfaceMapper);
  surfaceActor-&gt;GetProperty()-&gt;SetColor(1.0000,0.3882,0.2784);

  // Create graphics stuff
  //
  vtkSmartPointer&lt;vtkRenderer&gt; ren1 =
    vtkSmartPointer&lt;vtkRenderer&gt;::New();
  ren1-&gt;SetBackground(.3, .4, .6);

  vtkSmartPointer&lt;vtkRenderWindow&gt; renWin =
    vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
  renWin-&gt;AddRenderer(ren1);
  renWin-&gt;SetSize(512,512);

  vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren =
    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
  iren-&gt;SetRenderWindow(renWin);

  // Add the actors to the renderer, set the background and size
  //
  ren1-&gt;AddActor(surfaceActor);

  // Generate an interesting view
  //
  ren1-&gt;ResetCamera();
  ren1-&gt;GetActiveCamera()-&gt;Azimuth(120);
  ren1-&gt;GetActiveCamera()-&gt;Elevation(30);
  ren1-&gt;GetActiveCamera()-&gt;Dolly(1.0);
  ren1-&gt;ResetCameraClippingRange();

  iren-&gt;Initialize();
  iren-&gt;Start();

  return EXIT_SUCCESS;
}

static vtkSmartPointer&lt;vtkPolyData&gt; ReadPolyData(const char *fileName)
{
  vtkSmartPointer&lt;vtkPolyData&gt; polyData;
  std::string extension = vtksys::SystemTools::GetFilenameExtension(std::string(fileName));
  if (extension == &quot;.ply&quot;)
  {
    vtkSmartPointer&lt;vtkPLYReader&gt; reader =
      vtkSmartPointer&lt;vtkPLYReader&gt;::New();
    reader-&gt;SetFileName (fileName);
    reader-&gt;Update();
    polyData = reader-&gt;GetOutput();
  }
  else if (extension == &quot;.vtp&quot;)
  {
    vtkSmartPointer&lt;vtkXMLPolyDataReader&gt; reader =
      vtkSmartPointer&lt;vtkXMLPolyDataReader&gt;::New();
    reader-&gt;SetFileName (fileName);
    reader-&gt;Update();
    polyData = reader-&gt;GetOutput();
  }
  else if (extension == &quot;.obj&quot;)
  {
    vtkSmartPointer&lt;vtkOBJReader&gt; reader =
      vtkSmartPointer&lt;vtkOBJReader&gt;::New();
    reader-&gt;SetFileName (fileName);
    reader-&gt;Update();
    polyData = reader-&gt;GetOutput();
  }
  else if (extension == &quot;.stl&quot;)
  {
    vtkSmartPointer&lt;vtkSTLReader&gt; reader =
      vtkSmartPointer&lt;vtkSTLReader&gt;::New();
    reader-&gt;SetFileName (fileName);
    reader-&gt;Update();
    polyData = reader-&gt;GetOutput();
  }
  else
  {
    vtkSmartPointer&lt;vtkPointSource&gt; points =
      vtkSmartPointer&lt;vtkPointSource&gt;::New();
    points-&gt;SetNumberOfPoints(100000);
    points-&gt;SetRadius(10.0);
    points-&gt;SetCenter(vtkMath::Random(-100, 100),
                      vtkMath::Random(-100, 100),
                      vtkMath::Random(-100, 100));
    points-&gt;SetDistributionToShell();
    points-&gt;Update();
    polyData = points-&gt;GetOutput();
  }
  return polyData;
}
</code></pre>

<p><strong>CMakeLists.txt</strong></p>
<pre><code class="cmake">cmake_minimum_required(VERSION 2.8)

PROJECT(ExtractSurface)

find_package(VTK REQUIRED)
include(${VTK_USE_FILE})

add_executable(ExtractSurface MACOSX_BUNDLE ExtractSurface.cxx)

target_link_libraries(ExtractSurface ${VTK_LIBRARIES})
</code></pre>

<p><strong>Download and Build ExtractSurface</strong></p>
<p>Click <a href="https://github.com/lorensen/VTKWikiExamplesTarballs/raw/master/ExtractSurface.tar">here to download ExtractSurface</a> and its <em>CMakeLists.txt</em> file.
Once the <em>tarball ExtractSurface.tar</em> has been downloaded and extracted,</p>
<pre><code>cd ExtractSurface/build 
</code></pre>

<p>If VTK is installed:</p>
<pre><code>cmake ..
</code></pre>

<p>If VTK is not installed but compiled on your system, you will need to specify the path to your VTK build:</p>
<pre><code>cmake -DVTK_DIR:PATH=/home/me/vtk_build ..
</code></pre>

<p>Build the project:</p>
<pre><code>make
</code></pre>

<p>and run it:</p>
<pre><code>./ExtractSurface
</code></pre>

<p><strong>WINDOWS USERS PLEASE NOTE:</strong> Be sure to add the VTK bin directory to your path. This will resolve the VTK dll's at run time.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../../" class="btn btn-neutral" title="Cxx"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../../" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script src="../../../js/theme.js"></script>

</body>
</html>
